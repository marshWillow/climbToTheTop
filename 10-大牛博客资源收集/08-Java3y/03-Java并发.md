#### 1.多线程基础

##### 进程和线程的区别

进程是资源分配的进本单位，线程是资源调度的基本单位

多线程的本质就是一心两用，普通人只能一次喜欢一个人，但是时间管理大师就可以同时吊着好几个人，从这个角度电脑就是决定渣男。

我们用电脑，可以放着音乐，敲着代码，还挂着微信，这就是多线程。

对于电脑，多线程能够提高资源利用率，对于java，多线程则是提高执行效率。

时间管理大师自然爽，可是也容易翻车。在java世界，就是保证线程安全。

线程安全本质就是你同时执行多个，结果要和单线程一致。

如何确保线程安全呢？

那就得考虑最坏的结果是什么？什么情况你不想看到。

比如，过情人节，你得跟所有情人约会，那就很难。

现实生活中，从空间和时间上去隔离。

针对线程，有三点，原子性，可见性，和有序性

那就是加锁，无脑加锁肯定影响性能。

加锁，不是没条件的，你找个借口让一个女朋友在哪等着，总得再设定个条件去安慰。

就比如，你女朋友A 和女朋友B，其实是闺蜜，都要带着你给闺蜜把把关，这下你就芭比Q了，

而死锁就是这样，要执行的线程和其他线程互相关联，互持资源。还都没法让步。

这怎么办呢？

方弃一个呗，

##### CAS

compare and swap 比较并交换，对应CPU指令cmpxchg

不加锁，如何保证你操作没问题呢？

那就简单验证一下呗，当前值，内存值和要改的值，

当前值和内存值比较，判断它有没有修改过，这就是CAS的核心，相等就修改内存，不等就重试或者放弃。

CAS有个问题，那就是ABA问题，

你想找个没有恋爱经验的女孩，然后你和这个女孩相处，发现她单纯快乐，然后你觉得她不像谈过恋爱，所以就追她了。

但你不知道的是，她最初却是快乐，第一任对象伤了她，第二任对象由治愈了她，而你只是她的第三任。

虽然吧，她的性格是你想要的，但和你最初追求是不一样的，而这就是ABA问题。

怎么解决呢，给对方的笑加个版本，

###### LongAdder 和AtomicLong

AtomicLong本质多线程操作同一个资源，只能有一个成功，其他自旋

LongAdder为了提速，那就只能用空间换时间。



#### synchronized

是一种互斥锁，将代码块和方法锁起来，一起只允许一个线程进入

#### AQS和ReentrantLock

#### 线程池

#### ThreadLocal

#### CountDownLatch和CyclicBarrier

#### Java内存模型