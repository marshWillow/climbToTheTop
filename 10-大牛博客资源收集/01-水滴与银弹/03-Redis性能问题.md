##### Redis真的变慢了吗？

你的业务API响应变长，并不代表就一定是redis的问题，首先需要排查服务

通常做法是在服务内部集成**链路追踪**，意思是在服务访问外部依赖的出入口，记录下每次请求外部依赖的响应延时。

排查后，发现确实是redsi造成的，这时候集中注意力处理redis问题就行

从你业务到redis这条链路变慢的原因可能有2个：

1. 网络问题，例如网线断了，网络丢包等
2. Redis本身的问题

网络问题，我们不做考虑，通常也不是我们能解决的，通知运维解决就行

今天，我们只从Redis的角度来排查延迟原因。

首先，你需要知道Redis在你的服务器上的基准性能。

##### 什么是基准性能？

基准性能就是指Redis在一台负载正常的机器上，最大的响应延迟和平均响应延迟分别是多少。

我们要知道，Redis在不同的环境下，性能差别很大。

低配环境，2ms延迟不算慢，高配置0.5ms也不行

所以，需要了解你的Redis在服务器上的基准性能。

如何做呢？

为了避免业务服务器的网络延迟，你需要直接在Redis服务器上测试实例的响应延迟。

执行以下命令，测试实例60秒内最大响应延迟:

```dos
 $ redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60
 Max latency so far:1microseconds.
 Max latency so far:15microseconds.
 Max latency so far:17microseconds.
 Max latency so far:18microseconds.
 Max latency so far:72microseconds.
```

显示最大延迟为72微秒

还可以使用以下命令，查看一段时间内Redis的最小、最大、平均访问延迟

```dos
$ redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1
min:0,max:1,avg:0.13(100 sanples) --1.01 seconds range
min:0,max:1,avg:0.12(100 sanples) --1.01 seconds range
min:0,max:1,avg:0.13(100 sanples) --1.01 seconds range
……
```

了解了基准性能的测试方法，按照如下步骤来测试你的Redis

1. 在同一个服务器上，测试一个正常Redis实例的基准性能
2. 找到你觉得可能变慢的Redis实例，测试这个实例的基准性能
3. 如果你发现，这个实例的运行延迟是正常的2倍以上，就可以认定这个实例却是变慢了

那知道了它变慢，如何排查问题的根源呢？

##### 使用复杂度过高的命令

第一步肯定是查慢日志。

Redis提供慢日志统计功能，记录了哪些命令在执行时耗时比较久

设置慢日志的阈值，例如设置阈值为5毫秒，保留最近500条记录

```sql
#命令执行耗时超过5毫秒，记录慢日志
CONFIG SEG slowlog-log-slower-than 5000
#只保留最近500条慢日志
CONFIG SET slowlog-max-len 500
```

经过你的设置，Redis就会记录延迟命令

通过如下命令就可以查询最近记录的慢日志：

```dos
127.0.0.1：6379> SLOWLOG get 5
1) 1) (integer)32693      #慢日志ID
   2) (integer)1593763337 #执行时间戳
   3) (integer)5299       #执行耗时（微秒）
   4) 1)"LRANGE"          #具体执行的命令和参数
   	  2)"uer_list:2000"
   	  3)"0"
   	  4)"-1"
```

通过慢日志，就可以知道在什么时间点，执行了哪些命令比较耗时

##### Redis导致延迟变大的原因有两种

第一种：在于命令本身，比如，使用O(N)以上复杂度的命令，例如SORT、SUNION、ZUNIONSTORE聚合类命令。或者N值特别大

第二种：可能命令没啥问题，但是一次需要返回给客户端的数据量过多，通过传输协议传输数据的时间过长

从资源使用率层面来分析，你Redis的ops（服务器每秒并发量）不是很大，但CPU使用率很高，那么很有可能是命令复杂度过高

Redis是单线程的，前面某个命令卡了，后面的请求只能排队等待，对于客户端来说，响应延迟也会边长。

针对上述情况，我们尽力不适用O(N)以上复杂度的命令，数据的聚合放在客户端操作

如果非要执行O（N）,保证N尽力的小（推荐N<=300）,每次获取尽力少的数据，让Redis及时处理

##### 操作bigkey

如何你查询了慢日志，发现并不是命令复杂度导致，set/del这种简单命令出现在日志中，这时候你需要怀疑你的实例是否写入bigkey。

Redis写入数据，需要给新数据分配内存，删除数据时，也会释放对应的内存空间。

如何一个key的value非常大，分配和释放内存会比较耗时，这种类型的key我们称之为bigkey

你需要评估一个key的数据大小，尽量避免数据过大

如何有了bigkey，我们可以通过Redis提供的命令行来扫描bigkey分布情况。

```dos
$ redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01
...
-------summary---------
Biggest string found 'key:291990' has 10 betes
Biggest list found 'mylist:004' has 40 items
Biggest set found 'myset:2386' has 38 members
……
```

从输出结果我们可以看出每种数据类型所占用的最大内存，以及每种数据类型在整个实例中占比和平均大小

这个命令的原理：就是Redis内部执行SCAN命令，遍历整个实例中所有的key，然后针对key的类型，分贝执行STRLEN、LLEN、HLEN、SCARD、ZCARD命令，获取String的长度，容器类型（List、Hash、Set、Zset）的元素个数

需要注意的是：

1. 扫描线上实例，OPS会突增，所以要控制扫描的频率，指定-i参数即可，它表示扫描后的休息时间，单位是秒
2. 扫描结果，对于容器类型只能扫描出元素最多的key，但是key的元素多，并不一定代表占用的内存也多，你需要根据业务情况，自己评估

针对bigkey，还有什么更好的解决方案呢？

优化策略：

1. 避免写入bigkey
2. Redis是4.0以上版本，用unlink名令替代DEL，此命令可以把释放内存的操作放到后台线程中执行
3. 6.0以上，可以开启lazy-free机制，执行del命令时，释放内存也会放到后台线程中执行

bigkey在分片集群模式下，对于数据的迁移有性能影响，以及数据过期、数据淘汰、透明大页都会受到它的影响。

##### 集中过期

如果你发现，平时没事，突然某个时间点出现延迟，出现的很有规律

这种情况，你要排查一下是不是设置了大量key集中过期的情况。

Redis的过期策略有被动和主动两种策略。

1. 被动：只有当访问某个key时才判断这个key是否要已过期，过期则删除
2. 主动：Redis内部维护一个定时任务，默认每隔100毫秒从全局的过期哈希表中随机取出20个key，然后删除过期的key，如果过期key的比例超过了25%，则继续重复这个过程，直到比例下降到25%以下，或者这次执行耗时超过25毫秒，才退出循环。

这个主动定时任务，在Redis主线程中执行。

换句话说，出现大量删除过期key的情况，必然影响应用程序访问Redis,此时就会出现Redis延迟变大。

更何况，过期删除的是一个bigkey，耗时会更久，而且这个操作延迟并不会记录在慢日志中。

慢日志只记录一个真正操作内存数据的命令耗时，这种主动策略是在命令真正之前执行的。

而这种情况也会出现，慢日志没记录，但却明显感知延迟变大

**如何处理？**

检查业务代码。在代码中搜索expireat/pexpireat关键字。

通过排查代码，确实存在集中过期逻辑，但这种逻辑又是必须的。

我们有两个方案来规避

1. 集中过期key增加一个随机过期时间，把集中过期打散

   ```
   #在过期时间点之后的5分钟内随机过期,伪代码如下
   redis.exireat(key,expire_time+randm(300))
   ```

2. Redis4.0以上，开启lazy-free机制，删除过期，会在后台线程处理，不会影响主线程

```
#释放过期key的内存，放到后台执行
lazyfree-lazy-expire yes
```

另外，通过运维也可以及时发现这种情况，

运维时，把Redis监控，关注expired_keys这一项，当这个指标突增，就要报警

##### 实例内存达到上限

当我们把Redis当做纯缓存使用时，通常会设置内存上限maxmemory，然后设置一个数据淘汰策略

如果实例内存达到上限，你就会发现，之后每次写入新数据，操作延迟都会变大

原因是，当内存达到上限，以后每次写入都需要先剔除一部分数据，而这个剔除旧数据的逻辑需要消耗时间

具体耗时，取决淘汰策略：

1. allkeys-lru：不管key是否设置过期，淘汰最近最少访问的key
2. volatile-lru：只淘汰最近最少访问，并设置了过期时间的key
3. allkeys-random：不管key是否设置，随机淘汰
4. volatile-random：随机淘汰设置了过期时间的key
5. allkeys-ttl：不管key是够设置，淘汰即将过期的key
6. noeviction：不淘汰任何key，达到最大内存，写入数据返回错误
7. allkeys-lfu：不管key是否设置，淘汰访问频率最低的key（4.0+版本支持）
8. volatile-lfu：只淘汰访问频率最低，且设置了过期时间的key（4.0+版本支持）

一般使用allkeys-lru、volatile-lru,处理逻辑是：

随机取出一批key，然后淘汰一个最少访问的key，之后把剩下的key暂存在一个池子里，继续随机取一批，并与之前的key比较，再淘汰一个最少访问的，直到内存降到最大内存之下。

我们要知道，淘汰策略与删除过期一样，都是在命令真正执行之前执行，会增加我们的操作延迟

如何优化？

1. 避免bigkey

2. 淘汰策略改为随机淘汰

3. 拆分实例，把淘汰key压力分淘到多个实例上

4. 在Redis4.0+版本，开启layz-free机制

   ```
   #淘汰key的内存，放到后台执行
   lazyfree-lazy-evication yes
   ```

   ##### fork耗时严重

   我们常常开启后台定时RDB和AOF rewrite功能，来保证数据安全性

   但是开启期间，Redis延迟变大。

   其实，当Redis开启了后台RDB和AOF rewrite之后，需要在主进程创建出一个子进程进行数据的持久化。

   创建子进程，要调用操作系统提供的fork函数

   fork执行时，主进程需要拷贝自己的内存页表给子进程，如果这个实例很大，这个拷贝的过程就会比较耗时

   fork过程会消耗大量的CPU资源，完成前，整个实例会被阻塞住，严重影响性能

   如何确认是因为fork耗时？

   执行INFO命令，查看，单位微秒。

   ```INFO
   #上一次fork耗时
   latest_fork_usec:59477
   ```

   除了数据持久化会生成RDB，主从节点第一次建立数据同步时，也会生成RDB，然后发给从节点进行一次全量同步。

   优化方案：

   1. 控制Redis实例的内存在10G以下
   2. 合理配置数据持久化策略：在slave节点执行RDB备份，推荐低峰执行，对于丢失数据不敏感的业务，可以关闭AOF
   3. 实例不要部署在虚拟机，虚拟机比物理机耗时更久
   4. 降低主从库全量同步的概率，适当调大repl-backlog-size参数

##### 开启内存大页

操作系统开启内存大页机制也会导致性能问题

什么是内存大页？
应用程序向操作系统申请内存时，是按内存页进行申请的，常规的内存大小是4kb

Linux内核从2.6.38开始，支持了内存大页机制，允许盛情2MB大小的内存

当主进程fork子进程，主进程依旧可以接受写请求的，进来的写请求采用Copy On Write（写时复制）的方式操作内存数据

换句话说，主进程需要修改数据，不是直接修改，而是先将这块内存数据拷贝出来，再修改这块新内存的数据，这就是写时复制。

好处是父进程有任何写操作，不会影响子进程的数据持久化。

但是，主进程拷贝内存时，要申请新内存，如果开启了内存大页，那么，哪怕只修改10B的数据，也会以2MB为单位想操作系统申请。

如何关闭内存大页？

```INfo
#查看是否开启内存大页
$ cat /sys/kernel/mm/transparent_hugepage/enabled
[always] madvise never
#输出always，表示开启额内存大页
$ echo never >/sys/kernel/mm/transparent_hugepage/enabled
```

内存大页可以降低应用程序申请内存的次数，但是Redis对性能要求敏感，所以不建议开启这个机制

##### 开启AOF

数据持久化也会影响Redis性能

