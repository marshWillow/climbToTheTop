#### 类和对象

所有的类都是引用类型

类包含构造器、变量和方法

将类看做人，变量就是人的身高，年龄啥的，方法是职业和技能，构造器则是类创建对象的根本途径。

你可以将构造器理解成大使馆，没有大使馆，两国之间根本没办法交流。

Java给类提供默认构造器，如果你写了，就用你的。

###### 修饰符

- static：修改方法和成员变量，表示它属于类的本身。

虽然很多人喜欢把static称为静态，它只是用来区分类成员属于类本身还是属于实例。

有了static，内存为它分配一块存储空间，用的时候，去访问它内存。

如果没有，用的时候，你得先实例化对象，对象给它分配空间。

这就是专职和外包的区别。

- 构造器：构造器的返回值总是当前类，

###### 对象、引用和指针

Java里的引用就是C里面的指针，只是为了开发者方便，自己封装起来了。

**this引用**

this总是指向调用该方法的对象。

static修饰的方法，无法使用this关键字，因此不能访问不适用static修饰的成员。

#### 方法详解

方法不能独立存在

长度可变的形参只能在最后，一个方法只能包含一个可变形参

##### 递归方法

递归包含了循环，调用了方法本身

##### 方法重载

##### 成员变量和局部变量
类里定义的变量叫成员

类加载的时候，系统自动为成员变量分配内存空间，自动指定初始值。

成员变量在堆内存

方法里定义的则是局部

局部变量需要自己主动赋初始值，只保存基本类型的值和对象的引用。

局部变量在栈内存

换句话说，把变量当明星来看，都是表演节目，但你学校迎新晚会，有啥资本去请一个天皇巨星呢？

##### 隐藏和封装

封装有两层意思，把该隐藏的隐藏，该暴露的暴露。

以前，我们说把对象当人看，一个员工，他既要把自己能力展现出来，又不能超脱领导控制。

###### 访问控制符

- private：只有自己可以访问
- default：一个包可以访问
- protected：子类可以访问
- public：公共访问

##### 深入构造器

##### super限定

父类方法被重写，super调用父类方法

子类实例化，从最顶层的父类开始实例。

##### 多态

引用变量有两个类型：编译时类型和运行时类型。

Java只能用它声明该变量类的方法，方法被重写则具有多态。

变量则不具有多态。

强制类型转换，先用instanceof判断是否可以成功转换。

##### 继承和组合

封装和继承原则相悖，但各有好处。

实际使用中，父类只暴露需要暴露的方法，其他用private变成私有。

需要暴露却又不想被重写的，用final修饰

允许子类重写，但不让其他类访问的，用protected修饰

null可以调用静态方法，无法访问实例成员。

##### 单例（Singleton）类

一个类始终只能创建一个实例，这个类就是单例

首先，我们清楚，创建实例就需要分配空间，便带来了系统开销。

类实例化是用构造器实现的，不想让你随便创建，那就把构造器隐藏起来。

隐藏后，还需要暴露给你一个方法，让你能够获取实例。

实例先自己缓存起来，然后用一个方法暴露给别人。

假如，公司需要后勤来负责员工的需求，缺电脑了，需要找后勤，过春节组织聚餐又找后勤，人事总不能今天招一个临时工，然后办完事再开了吧。

合理的是，有事就找后勤，后勤一直养着，永远保证是一个人。

对于后勤这个职位来说，就是单例类，他不能暴露招聘接口，谁都有权利去招一个，

而是你有需求可以用，但只能用公司指定的。

##### 五种单例写法

- 懒汉式

  先缓存一个null，直到第一次实例，判断为null的时候再去创建

  ```java
  / 懒汉式单例
  public class Singleton {
      // 指向自己实例的私有静态引用
      private static Singleton singleton;
      // 私有的构造方法
      private Singleton(){}
      // 以自己实例为返回值的静态的公有方法，静态工厂方法
      public static Singleton getSingleton(){
          // 被动创建，在真正需要使用时才去创建
          if (singleton == null) {
              singleton = new Singleton();
          }
          return singleton;
      }
  }
  ```

  缺点：只能在单线程下使用，多线程，不可使用

- 饿汉式

  初始化就已经建好，比较浪费空间

  ```java
  
  // 饿汉式单例
  public class Singleton {
      // 指向自己实例的私有静态引用，主动创建
      private static Singleton singleton = new Singleton();
      // 私有的构造方法
      private Singleton(){}
      // 以自己实例为返回值的静态的公有方法，静态工厂方法
      public static Singleton getSingleton(){
          return singleton;
      }
  }
  ```

  缺点：写法虽然简单，就是实例没用，就把内存浪费了。

- 双检锁

  ```java
  public class Singleton
      {
          private static Singleton instance;
          //程序运行时创建一个静态只读的进程辅助对象
          private static readonly object syncRoot = new object();
          private Singleton() { }
          public static Singleton GetInstance(){
              //先判断是否存在，不存在再加锁处理
              if (instance == null) {
                  //在同一个时刻加了锁的那部分程序只有一个线程可以进入
                  lock (syncRoot){
                      if (instance == null){
                          instance = new Singleton();
                      }
                  }
              }
              return instance;
          }
      }
  
  
  ```

  volatile修饰符阻止变量访问前后的指令重排，保证了指令执行顺序。

- 静态内部类

  ```java
  public class Singleton {
      // 指向自己实例的私有静态引用，主动创建
      private static class LazyHolder{
           private static final Singleton INSTANCE= new Singleton();
      }
      // 私有的构造方法
      private Singleton(){}
      // 以自己实例为返回值的静态的公有方法，静态工厂方法
      public static Singleton getSingleton(){
          return LazyHolder.INSTANCE;
      }
  }
  ```

  缺点：反射强行重复构建

  利用反射打破单例

  ```java
  //获得构造器
  Constructor con = Singleton.class.getDeclaredConstructor();
  //设置为可访问
  con.setAccessible(true);
  //构造两个不同的对象
  Singleton singleton1 = (Singleton)con.newInstance();
  Singleton singleton2 = (Singleton)con.newInstance
      
  //代码可以简单归纳为三个步骤：
  //第一步，获得单例类的构造器。
  //第二步，把构造器设置为可访问。
  //第三步，使用newInstance方法构造对象。
  //最后为了确认这两个对象是否真的是不同的对象，我们使用equals方法进行比较。毫无疑//问，比较结果是false。 
  
  ```

  

- 枚举

```
public enum Singleton{
	INSTANCE;
	public void anyMethod(){}
}

```

缺点：并非使用懒加载，单例对象在枚举类被加载的时候进行初始化

##### final修饰符

让变量不可变

Java八个包装类和java.lang.String都是不可变类。

状态不可变，所以为了减少开销，可以考虑对实例进行缓存。

##### 抽象类

必须使用abstract修饰符定义

##### 接口

interface

接口支持多继承

##### 面向接口编程

设计模式，就是一种成熟的思维方式。

你妈跟你说天冷记得穿秋裤，你不懂，等你冻一次就老实了。

###### 简单工厂模式
因为接口多继承的特性，那么，就可以降低代码间的耦合。

你喜欢吃蛋糕，你可以选择自己做着吃。但需要你去学，还得买材料啥的。

但是你留了蛋糕房地址，这就不一样了。

你想吃蛋糕得时候，打个电话，蛋糕房就送过来了。

这就是简单工厂模式。

让专业的人做专业的事。

针对代码实现，

定义一个人，引入蛋糕房接口，接口由几个蛋糕类实现。

##### 内部类

一个类代表一个独立个子的话，把一个类放在另一个类内部，是为什么呢？

类比现实，一个人断了一条腿，需要安装一个假肢，而假肢针对哪个人定制。

而内部类解决的就是，它却是是一个对象，而这个对象，却又依赖另一个对象而产生意义。

人是外部类，假肢是内部类。没假肢，人不能走路，但人还是人。但假肢没了这个人，

它根本没啥意义，反正别人也用不了它。

基于这种情况，我们可以理解以下几点准则：

- 内部类离开外部类无意义，且不允许其他类访问
- 内部类能访问外部类数据，但外部类不放访问内部类实现细节（造假肢需要了解人的熟悉 ，但使用人却不用管它怎么制造完成）
- 非静态内部类，不能拥有静态成员。这是为了隐藏细节

###### 匿名内部类

不能是抽象类，不能定义构造器。


